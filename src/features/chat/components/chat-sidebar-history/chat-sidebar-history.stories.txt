// import preview from "#.storybook/preview";
// import { QueryProvider } from "@/providers/query-provider";
// import { expect, mocked, waitFor } from "storybook/test";

// import { SidebarProvider } from "@/components/ui/sidebar";

// import { auth } from "@/features/auth/services/auth";

// import { CHAT_VISIBILITY } from "@/features/chat/lib/constants";
// import type { DBChatId, UIChat } from "@/features/chat/lib/types";
// import {
//     ChatCacheSyncProvider,
//     ChatOffsetProvider,
//     ChatSidebarProvider,
// } from "@/features/chat/providers";
// import { getUserChats } from "@/features/chat/services/db";

// import { USER_ROLE } from "@/features/user/lib/constants/user-roles";
// import type { DBUserId } from "@/features/user/lib/types";

// import { ORDER_BY } from "@/lib/constants";
// import type { PaginatedData } from "@/lib/types";

// import { ChatSidebarHistory } from "./chat-sidebar-history";

// const mockUserId = "user-123" as unknown as DBUserId;

// const mockSession = {
//     user: {
//         id: mockUserId,
//         name: "Test User",
//         email: "test@example.com",
//         image: "https://example.com/avatar.jpg",
//         role: USER_ROLE.USER,
//     },
// };

// const createMockChat = (
//     id: string,
//     title: string,
//     daysAgo: number = 0,
// ): UIChat => {
//     const date = new Date();
//     date.setDate(date.getDate() - daysAgo);
//     return {
//         id: id as DBChatId,
//         title,
//         visibility: CHAT_VISIBILITY.PRIVATE,
//         createdAt: date.toISOString(),
//         updatedAt: date.toISOString(),
//         visibleAt: date.toISOString(),
//     };
// };

// const mockChats: UIChat[] = [
//     createMockChat("chat-1", "First Chat", 0),
//     createMockChat("chat-2", "Second Chat", 1),
//     createMockChat("chat-3", "Third Chat", 2),
//     createMockChat("chat-4", "Fourth Chat", 7),
//     createMockChat("chat-5", "Fifth Chat", 30),
// ];

// const mockPaginatedData: PaginatedData<UIChat[]> = {
//     data: mockChats,
//     totalCount: mockChats.length,
//     hasNextPage: false,
//     nextOffset: undefined,
// };

// const meta = preview.meta({
//     component: ChatSidebarHistory,
//     decorators: [
//         Story => (
//             <QueryProvider>
//                 <SidebarProvider>
//                     <ChatOffsetProvider>
//                         <ChatCacheSyncProvider>
//                             <ChatSidebarProvider>
//                                 <Story />
//                             </ChatSidebarProvider>
//                         </ChatCacheSyncProvider>
//                     </ChatOffsetProvider>
//                 </SidebarProvider>
//             </QueryProvider>
//         ),
//     ],
//     parameters: {
//         nextjs: {
//             appDirectory: true,
//         },
//     },
//     argTypes: {
//         className: {
//             control: "text",
//             description: "Additional CSS classes",
//             table: {
//                 type: {
//                     summary: "string",
//                 },
//             },
//         },
//     },
// });

// export const Default = meta.story({
//     name: "Default",
//     parameters: {
//         nextjs: {
//             appDirectory: true,
//         },
//     },
//     loaders: [
//         async () => {
//             mocked(auth).mockResolvedValue(mockSession as any);
//             mocked(getUserChats).mockResolvedValue(mockPaginatedData);
//         },
//     ],
// });

// Default.test("should render chat history with chats", async ({ canvas }) => {
//     mocked(auth).mockResolvedValue(mockSession as any);
//     mocked(getUserChats).mockResolvedValue(mockPaginatedData);

//     await waitFor(() => {
//         const sidebarGroup = canvas.getByRole("group");
//         expect(sidebarGroup).toBeInTheDocument();
//     });

//     // Check that chat items are rendered
//     await waitFor(() => {
//         const chatItems = canvas.queryAllByRole("listitem");
//         expect(chatItems.length).toBeGreaterThan(0);
//     });
// });

// Default.test(
//     "should call auth and getUserChats with correct parameters",
//     async () => {
//         mocked(auth).mockResolvedValue(mockSession as any);
//         mocked(getUserChats).mockResolvedValue(mockPaginatedData);

//         await waitFor(() => {
//             expect(mocked(auth)).toHaveBeenCalled();
//             expect(mocked(getUserChats)).toHaveBeenCalledWith({
//                 userId: mockUserId,
//                 limit: 40,
//                 orderBy: ORDER_BY.UPDATED_AT,
//             });
//         });
//     },
// );

// export const Empty = meta.story({
//     name: "Empty State",
//     parameters: {
//         nextjs: {
//             appDirectory: true,
//         },
//     },
//     loaders: [
//         async () => {
//             mocked(auth).mockResolvedValue(mockSession as any);
//             mocked(getUserChats).mockResolvedValue({
//                 data: [],
//                 totalCount: 0,
//                 hasNextPage: false,
//                 nextOffset: undefined,
//             });
//         },
//     ],
// });

// Empty.test(
//     "should render empty state when no chats exist",
//     async ({ canvas }) => {
//         mocked(auth).mockResolvedValue(mockSession as any);
//         mocked(getUserChats).mockResolvedValue({
//             data: [],
//             totalCount: 0,
//             hasNextPage: false,
//             nextOffset: undefined,
//         });

//         await waitFor(() => {
//             // The empty state component should be rendered
//             const sidebarGroup = canvas.getByRole("group");
//             expect(sidebarGroup).toBeInTheDocument();
//         });
//     },
// );

// export const Error = meta.story({
//     name: "Error State",
//     parameters: {
//         nextjs: {
//             appDirectory: true,
//         },
//     },
//     loaders: [
//         async () => {
//             mocked(auth).mockResolvedValue(mockSession as any);
//             mocked(getUserChats).mockRejectedValue(
//                 new Error("Failed to fetch chats"),
//             );
//         },
//     ],
// });

// Error.test(
//     "should render error message when getUserChats fails",
//     async ({ canvas }) => {
//         mocked(auth).mockResolvedValue(mockSession as any);
//         mocked(getUserChats).mockRejectedValue(
//             new Error("Failed to fetch chats"),
//         );

//         await waitFor(() => {
//             const errorMessage = canvas.getByText(
//                 /Failed to fetch chats. Please try again later./i,
//             );
//             expect(errorMessage).toBeInTheDocument();
//         });
//     },
// );

// Error.test(
//     "should render default error message when error is not an Error instance",
//     async ({ canvas }) => {
//         mocked(auth).mockResolvedValue(mockSession as any);
//         mocked(getUserChats).mockRejectedValue("Unknown error");

//         await waitFor(() => {
//             const errorMessage = canvas.getByText(
//                 /An error occurred while fetching your chats. Please try again later./i,
//             );
//             expect(errorMessage).toBeInTheDocument();
//         });
//     },
// );

// export const WithManyChats = meta.story({
//     name: "With Many Chats",
//     parameters: {
//         nextjs: {
//             appDirectory: true,
//         },
//     },
//     loaders: [
//         async () => {
//             const manyChats: UIChat[] = Array.from({ length: 50 }, (_, i) =>
//                 createMockChat(`chat-${i}`, `Chat ${i}`, i),
//             );

//             mocked(auth).mockResolvedValue(mockSession as any);
//             mocked(getUserChats).mockResolvedValue({
//                 data: manyChats,
//                 totalCount: manyChats.length,
//                 hasNextPage: true,
//                 nextOffset: 40,
//             });
//         },
//     ],
// });

// WithManyChats.test(
//     "should render many chats and show pagination skeleton",
//     async ({ canvas }) => {
//         const manyChats: UIChat[] = Array.from({ length: 50 }, (_, i) =>
//             createMockChat(`chat-${i}`, `Chat ${i}`, i),
//         );

//         mocked(auth).mockResolvedValue(mockSession as any);
//         mocked(getUserChats).mockResolvedValue({
//             data: manyChats,
//             totalCount: manyChats.length,
//             hasNextPage: true,
//             nextOffset: 40,
//         });

//         await waitFor(() => {
//             const sidebarGroup = canvas.getByRole("group");
//             expect(sidebarGroup).toBeInTheDocument();
//         });
//     },
// );

// export const WithNoSession = meta.story({
//     name: "No Session",
//     parameters: {
//         nextjs: {
//             appDirectory: true,
//         },
//     },
//     loaders: [
//         async () => {
//             mocked(auth).mockResolvedValue(null);
//         },
//     ],
// });

// WithNoSession.test("should throw error when session is null", async () => {
//     mocked(auth).mockResolvedValue(null);

//     // The component should throw an AuthenticationError
//     // This is handled by the error boundary in the app
//     await waitFor(() => {
//         expect(mocked(auth)).toHaveBeenCalled();
//     });
// });
// export default {};
export default {};
